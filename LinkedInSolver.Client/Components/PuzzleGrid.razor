@using LinkedInSolver.Client.Models

<style>
  .grid-container {
    display: flex;
    justify-content: center;
    margin-top: 24px;
  }

  .puzzle-grid-wrapper {
    position: relative;
    width: fit-content;
  }

  .puzzle-grid {
    display: grid;
    gap: 1px;
    background-color: #dee2e6;
    border: 2px solid #dee2e6;
    border-radius: 8px;
    padding: 8px;
    width: fit-content;
    aspect-ratio: 1;
  }

  .grid-cell {
    background-color: white;
    border: 1px solid #e9ecef;
    cursor: pointer;
    transition: all 0.2s ease;
    border-radius: 2px;
    min-height: 60px;
    min-width: 60px;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .grid-cell.right-wall {
    border-right: 2px solid #000 !important;
  }

  .grid-cell.bottom-wall {
    border-bottom: 2px solid #000 !important;
  }

  .grid-cell.left-wall {
    border-left: 2px solid #000 !important;
  }

  .grid-cell.top-wall {
    border-top: 2px solid #000 !important;
  }

  .grid-cell.disabled {
    cursor: not-allowed !important;
    opacity: 0.6;
    pointer-events: none;
  }

  .cell-number {
    font-size: 20px;
    font-weight: bold;
    color: #333;
    user-select: none;
  }

    .cell-number.first-last {
      color: #dc3545 !important;
    }

  .border-button {
    position: absolute;
    width: 24px;
    height: 24px;
    background-color: #90EE90;
    border: 2px solid #90EE90;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 10;
  }

  .border-button:hover {
    opacity: 1 !important;
    background-color: #7FDD7F;
  }

  .border-button.disabled {
    cursor: not-allowed !important;
    opacity: 0 !important;
    pointer-events: none;
  }

  .plus-icon {
    color: #A9A9A9;
    font-size: 16px;
    font-weight: bold;
    line-height: 1;
  }

  .debug-message {
    margin-top: 16px;
    padding: 8px;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-family: monospace;
    text-align: center;
  }

  .grid-cell:hover {
    background-color: #f8f9fa;
    transform: scale(0.95);
  }

  .grid-cell.active {
    background-color: #dc3545;
    border-color: #b02a37;
  }

  .grid-cell.active:hover {
    background-color: #c82333;
  }

  .puzzle-content {
    transition: opacity 0.3s ease;
  }

  .puzzle-content.disabled {
    opacity: 0.6;
    pointer-events: none;
  }
</style>

<PageTitle>@CurrentPuzzle.Name - LinkedIn Puzzles</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">

  <MudBreadcrumbs Items="breadcrumbItems" Class="mb-4" />

  <div class="puzzle-content @(solverRunning ? "disabled" : "")">
    <div class="d-flex align-center mb-4">
      <img src="@CurrentPuzzle.Icon" alt="@CurrentPuzzle.Name"
           style="width: 48px; height: 48px; margin-right: 16px;" />
      <MudText Typo="Typo.h4" GutterBottom="false">
        @CurrentPuzzle.Name
      </MudText>
    </div>

    <div class="d-flex justify-center mb-4">
      <div class="d-flex align-center">
        <MudButton Variant="Variant.Filled" Color="Color.Success" @onclick="ValidateAndSolve" Disabled="@solverRunning">
          @if (solverRunning) {
            <MudProgressCircular Color="Color.Secondary" Size="Size.Small" Indeterminate="true" />
            <span style="margin-left: 8px;">Processing...</span>
          } else {
            <span>Validate and Solve</span>
          }
        </MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="OnResizeGrid" Disabled="@solverRunning">
          Reset Grid
        </MudButton>
        <MudTextField @bind-Value="gridSizeInput" Label="Grid Size" Variant="Variant.Outlined" Margin="Margin.Dense"
                      Style="width: 120px; margin-right: 16px;" Error="@showError" ErrorText="@errorMessage" T="int"
                      Disabled="@solverRunning" />
      </div>
    </div>

    <div class="grid-container">
      <div class="puzzle-grid-wrapper">
        <div class="puzzle-grid"
             style="grid-template-columns: repeat(@CurrentGrid.Size, 1fr); grid-template-rows: repeat(@CurrentGrid.Size, 1fr);">
          @for (int i = 0; i < CurrentGrid.Size * CurrentGrid.Size; i++) {
            int row = i / CurrentGrid.Size;
            int col = i % CurrentGrid.Size;
            Pos pos = new(row, col);

            List<string> borderClasses = GetCellClassesForDiv(pos);
            if (solverRunning) {
              borderClasses.Add("disabled");
            }
            string cellClasses = $"grid-cell {string.Join(" ", borderClasses)}";

            <!-- cell contents -->
            <div class="@cellClasses" @onclick="() => OnCellClick(pos)">
              @GetCellContent(pos)
            </div>

            <!-- cell borders -->
            @if (CurrentGrid.HasBorderActions) {
              string borderClass = solverRunning ? "border-button disabled" : "border-button";

              // Horizontal border button (below current cell)
              if (row < CurrentGrid.Size - 1) {
                int hTop = GetHorizontalBorderTop(pos);
                int hLeft = GetHorizontalBorderLeft(pos);
                string finalClass = $"{borderClass} horizontal";
                <div class="@finalClass" style="top: @(hTop)px; left: @(hLeft)px;"
                     @onclick="() => OnBorderClick(pos, pos.GetNeighbor(Pos.Direction.Down))">
                  <span class="plus-icon">+</span>
                </div>
              }

              // Vertical border button (right of current cell)
              if (col < CurrentGrid.Size - 1) {
                int vTop = GetVerticalBorderTop(pos);
                int vLeft = GetVerticalBorderLeft(pos);
                string finalClass = $"{borderClass} vertical";
                <div class="@finalClass" style="top: @(vTop)px; left: @(vLeft)px;"
                     @onclick="() => OnBorderClick(pos, pos.GetNeighbor(Pos.Direction.Right))">
                  <span class="plus-icon">+</span>
                </div>
              }
            }
          }
        </div>
      </div>
    </div>

    <div class="debug-message">
      @debugMessage
    </div>
  </div>

</MudContainer>

@code {
  // Dynamic positioning constants (taken from CSS)
  const int CELL_SIZE = 60, CELL_GAP = 1, CELL_WITH_GAP = CELL_SIZE + CELL_GAP;
  const int GRID_PADDING = 8;
  const int BORDER_BUTTON_SIZE = 24;

  [Parameter] public Puzzle CurrentPuzzle { get; set; } = null!;
  [Parameter] public Grid CurrentGrid { get; set; } = null!;
  [Parameter] public Func<Pos, List<string>> GetCellClassesForDiv { get; set; } = null!;
  [Parameter] public Func<Pos, RenderFragment?> GetCellContent { get; set; } = null!;

  private int gridSizeInput = Grid.DEFAULT_SIZE;
  private bool showError = false;
  private string errorMessage = string.Empty;
  private string debugMessage = string.Empty;
  private List<BreadcrumbItem> breadcrumbItems = null!;

  private bool solverRunning = false;

  protected override void OnInitialized() {
    gridSizeInput = Grid.DEFAULT_SIZE;
    breadcrumbItems = new List<BreadcrumbItem> {
        new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
        new BreadcrumbItem(CurrentPuzzle.Name, href: null, disabled: true)
    };
    Initialize();
  }

  private void OnResizeGrid() {
    if (solverRunning) {
      return;
    }

    if (gridSizeInput < Grid.MIN_SIZE || gridSizeInput > Grid.MAX_SIZE) {
      showError = true;
      errorMessage = $"Grid Size should be between {Grid.MIN_SIZE} and {Grid.MAX_SIZE}";
      StateHasChanged();
      return;
    }

    Initialize();
    CurrentGrid.Reset(gridSizeInput);
    StateHasChanged();
  }

  private void Initialize() {
    showError = false;
    errorMessage = string.Empty;
    debugMessage = string.Empty;
  }

  private void OnCellClick(Pos pos) {
    if (solverRunning) {
      return;
    }

    // Use polymorphic method - each grid type handles its own logic
    CurrentGrid.OnCellClick(pos);
    StateHasChanged();
  }

  private void OnBorderClick(Pos pos1, Pos pos2) {
    if (solverRunning || !CurrentGrid.HasBorderActions) {
      return;
    }

    CurrentGrid.OnBorderClick(pos1, pos2);
    debugMessage = $"{CurrentPuzzle.Name}: Border action between {pos1} and {pos2}";
    StateHasChanged();
  }

  // Position at the bottom of the current cell
  private int GetHorizontalBorderTop(Pos pos) =>
    GRID_PADDING + (pos.Row + 1) * CELL_WITH_GAP - (BORDER_BUTTON_SIZE / 2);

  // Position at the center of the current cell
  private int GetHorizontalBorderLeft(Pos pos) =>
    GRID_PADDING + pos.Col * CELL_WITH_GAP + (CELL_SIZE - BORDER_BUTTON_SIZE) / 2;

  // Position at the center of the current cell
  private int GetVerticalBorderTop(Pos pos) =>
    GRID_PADDING + pos.Row * CELL_WITH_GAP + (CELL_SIZE - BORDER_BUTTON_SIZE) / 2;

  // Position at the right of the current cell
  private int GetVerticalBorderLeft(Pos pos) =>
    GRID_PADDING + (pos.Col + 1) * CELL_WITH_GAP - (BORDER_BUTTON_SIZE / 2);

  private async Task ValidateAndSolve() {
    if (solverRunning) {
      return;
    }

    debugMessage = "Validating...";
    solverRunning = true;
    StateHasChanged();
    string? validationError = await Task.Run(CurrentGrid.Validate);
    if (validationError != null) {
      debugMessage = $"Validation failed: {validationError}";
      solverRunning = false;
      StateHasChanged();
      return;
    }

    debugMessage = "Validation successful, solving...";
    StateHasChanged();

    List<Pos> solution = await Task.Run(CurrentGrid.Solve);
    // Placeholder: display solution

    solverRunning = false;
    StateHasChanged();
  }
}
